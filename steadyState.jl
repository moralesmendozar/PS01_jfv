module ss_deterministic
export ss_solver
using NLsolve

function ss_solver(xinit, α, β, δ, θ )

    function focs!(F,x)
        c1 = x[3]^α * x[1]^(1-α) - δ * x[3]
        # FOC [l1]
        F[1] = θ * (1-α)*x[3]^α*x[1]^(-α) * (c1)^(θ-1)*x[2]^(1-θ) - x[1] - x[2]
        # FOC [l2]
        F[2] = ( 1 - θ)* (c1)^θ * x[2]^(-θ) - x[1] - x[2]
        # FOC [k]
        F[3] =  β*( α * (x[1])^(1-α) * (x[3])^(α-1)+ 1 - δ) - 1
    end

    function Jfocs!(J,x)
        c1 = x[3]^α * x[1]^(1-α) - δ * x[3]

        # Deriv, eq 01:
        aux1 = θ * (1-α) * x[3]^(α) * x[1]^(-α)
        J[1,1] = aux1 * ( -α *(c1)^(θ-1)*x[2]^(1-θ)* x[1]^(-1) + (θ-1)* c1^(θ-2)* x[2]^(1-θ) * (1-α)*x[3]^(α) * x[1]^(-α)   ) - 1
        J[1,2] = θ*(1-θ)* c1^(θ-1) * x[2]^(-θ)* (1-α) * x[3]^α * x[1]^(-α) - 1
        J[1,3] = aux1 * ( α * (c1)^(θ - 1) *x[2]^(1-θ) * x[3]^(-1)    +    (θ-1) *(c1)^(θ-2)*x[2]^(1-θ)* (α*x[3]^(α-1)*x[1]^(1-α) - δ)  )

        # Deriv, eq 02:
        J[2,1] = θ * (1-θ )* c1^(θ - 1) * x[2]^(-θ) * (1-α) * x[3]^(α) * x[1]^(-α)  - 1
        J[2,2] = -θ * (1-θ ) * c1^(θ) * x[2]^(-1-θ) - 1
        J[2,3] = θ * (1-θ )* c1^(θ - 1) * x[2]^(-θ) * ( α * x[3]^(α-1) * x[1]^(1-α)  - δ)

        # Deriv, eq 03:
        J[3,1] = α *β *(1 - α) * x[3]^(α-1) * x[1]^(-α)
        J[3,2] = 0
        J[3,3] = α *β *(α - 1) * x[3]^(α-2) * x[1]^(1-α)
    end

    rsoltn = nlsolve(focs!,Jfocs!, xinit)
    #rsoltn = nlsolve(focs!, xinit)
    return rsoltn
end

end
